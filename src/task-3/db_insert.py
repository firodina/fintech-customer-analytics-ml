"""
Task 3: Insert cleaned and processed review data into PostgreSQL.
Uses the 'sentiment_thematic.csv' file generated by previous steps.
Requires: psycopg2
"""

import pandas as pd
import psycopg2
import psycopg2.extras
from pathlib import Path
from IPython.display import display
import sys

# -----------------------------
# ‚úÖ Fix: Import OUTPUT_DIR from task-2/utils.py
# -----------------------------
task2_utils_path = Path(__file__).parent.parent / "task-2"
if str(task2_utils_path.resolve()) not in sys.path:
    sys.path.append(str(task2_utils_path.resolve()))

try:
    from utils import OUTPUT_DIR
    print(f"‚úÖ Found utils at: {task2_utils_path.resolve()}")
except ImportError as e:
    raise ImportError(f"‚ùå Could not import utils from task-2: {e}")

# -----------------------------
# Database Configuration
# -----------------------------
DB_NAME = "bank_reviews"
DB_USER = "postgres"
DB_PASS = "root"
DB_HOST = "localhost"
DB_PORT = "5432"

# Input file and SQL schema
INPUT_FILE = OUTPUT_DIR / "sentiment_thematic.csv"
SQL_SCHEMA_FILE = Path(__file__).parent / "db_setup.sql"


# -----------------------------
# Database Connection
# -----------------------------
def connect_to_db(db_name=DB_NAME):
    try:
        conn = psycopg2.connect(
            dbname=db_name,
            user=DB_USER,
            password=DB_PASS,
            host=DB_HOST,
            port=DB_PORT
        )
        print(f"‚úÖ Connected to PostgreSQL database: {db_name}")
        return conn
    except psycopg2.OperationalError as e:
        print(f"‚ùå Connection Error: {e}")
        return None


# -----------------------------
# Setup Schema
# -----------------------------
def setup_schema(conn):
    print("\n--- 1. Creating Required Tables ---")
    if not SQL_SCHEMA_FILE.exists():
        print(f"‚ùå SQL schema file not found at {SQL_SCHEMA_FILE}")
        return False

    try:
        with open(SQL_SCHEMA_FILE, "r") as f:
            sql_commands = f.read()
        cursor = conn.cursor()
        cursor.execute(sql_commands)
        conn.commit()
        cursor.close()
        print("‚úÖ Schema executed (tables created or already existed).")
        return True
    except Exception as e:
        conn.rollback()
        print(f"‚ùå Error during schema setup (expected if tables exist): {e}")
        return False


# -----------------------------
# Insert Data
# -----------------------------
def insert_data(conn, df):
    cursor = conn.cursor()

    # 1Ô∏è‚É£ Insert unique banks
    print("\n--- 2. Inserting Banks ---")
    bank_names = df["bank_name"].unique()
    bank_id_map = {}

    for name in bank_names:
        try:
            cursor.execute(
                "INSERT INTO Banks (bank_name) VALUES (%s) "
                "ON CONFLICT (bank_name) DO UPDATE SET bank_name=EXCLUDED.bank_name "
                "RETURNING bank_id",
                (name,)
            )
            bank_id = cursor.fetchone()[0]
            bank_id_map[name] = bank_id
        except Exception as e:
            conn.rollback()
            print(f"‚ùå Error inserting bank {name}: {e}")
            raise

    df["bank_id"] = df["bank_name"].map(bank_id_map)

    # 2Ô∏è‚É£ Insert reviews
    print("\n--- 3. Inserting Reviews ---")
    data_to_insert = df[[
        "review_id", "bank_id", "review_text", "rating",
        "review_date", "sentiment_label", "sentiment_score", "themes", "source"
    ]].copy()

    # Replace NaNs with None for SQL
    data_to_insert = data_to_insert.where(pd.notnull(data_to_insert), None)
    rows_to_insert = [tuple(row) for row in data_to_insert.values]

    try:
        print(f"Attempting to insert/update {len(rows_to_insert)} reviews...")
        psycopg2.extras.execute_batch(
            cursor,
            "INSERT INTO Reviews (review_id, bank_id, review_text, rating, review_date, "
            "sentiment_label, sentiment_score, themes, source) "
            "VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s) "
            "ON CONFLICT (review_id) DO NOTHING",
            rows_to_insert
        )
        conn.commit()
        cursor.execute("SELECT COUNT(*) FROM Reviews;")
        current_count = cursor.fetchone()[0]
        print(f"‚úÖ Insertion finished. Total reviews in DB: {current_count}")
    except Exception as e:
        conn.rollback()
        print(f"‚ùå Critical Error inserting reviews: {e}")
        raise
    finally:
        cursor.close()


# -----------------------------
# Verify Data Integrity
# -----------------------------
def verify_data_integrity(conn):
    cursor = conn.cursor()
    print("\n--- 4. Verifying Data Integrity ---")
    cursor.execute("SELECT COUNT(*) FROM Reviews;")
    count = cursor.fetchone()[0]
    print(f"Total reviews in database: {count}")

    avg_rating_query = """
    SELECT b.bank_name, AVG(r.rating) AS average_rating, COUNT(r.review_id) AS total_reviews
    FROM Reviews r
    JOIN Banks b ON r.bank_id = b.bank_id
    GROUP BY b.bank_name
    ORDER BY total_reviews DESC;
    """
    cursor.execute(avg_rating_query)
    results = cursor.fetchall()
    df_verification = pd.DataFrame(
        results, columns=["Bank Name", "Average Rating", "Total Reviews"]).round(2)
    display(df_verification)
    cursor.close()


# -----------------------------
# Main Function
# -----------------------------
def main():
    # Load CSV
    if not INPUT_FILE.exists():
        print(f"‚ùå Input file not found at {INPUT_FILE}")
        return
    df = pd.read_csv(INPUT_FILE)
    print(f"Loaded {len(df)} reviews.")

    # Ensure review_date is proper format
    if "review_date" in df.columns:
        df["review_date"] = pd.to_datetime(
            df["review_date"], errors='coerce').dt.date

    # Connect to DB
    conn = connect_to_db()
    if conn is None:
        return

    try:
        setup_schema(conn)
        insert_data(conn, df)
        verify_data_integrity(conn)
    except Exception as e:
        print(f"\n‚ùå Critical error: {e}")
    finally:
        if conn:
            conn.close()
            print("\nüîí Database connection closed.")


# -----------------------------
# Entry Point
# -----------------------------
if __name__ == "__main__":
    main()
